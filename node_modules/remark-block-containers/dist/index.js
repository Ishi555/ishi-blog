import { visit } from 'unist-util-visit';
import { findAfter } from 'unist-util-find-after';
import { findAllBetween } from 'unist-util-find-between-all';
import { nanoid } from 'nanoid';
const settings = {
    containerClass: 'block-default',
    containerType: 'div',
    titleType: 'p',
    titleClass: 'block-title',
};
const TAGS_ALIAS = ['info', 'tip', 'warning', 'danger', 'details', 'code-group'];
export const PARAM_REG = /([A-Za-z0-9_-]+)(\{([\.|#])(\w+)\})?/iu;
export const CONTAINER_START = /^:{3} *([A-Za-z0-9_-]+)?(\{([\.|#])(\w+)\})?( .+)?/i;
export const CONTAINER_END = /\s*\n*?:{3}$/;
export const BAD_CONTAINER_REG = /^:{3}\s+:{3}\s*.*/;
function createTitle(title, type = settings.titleType) {
    return {
        type: 'paragraph',
        children: [{ type: 'text', value: title.replace(/\s+/g, ' ') }],
        data: {
            hName: type,
            hProperties: {
                className: [settings.titleClass],
            },
        },
    };
}
function createContainer(type, props, children) {
    return {
        type: 'container',
        children,
        data: {
            hName: type,
            hProperties: {
                ...props,
                className: [settings.containerClass, ...props.className],
            },
        },
    };
}
function createTabs(nodes) {
    const groupName = `group-${nanoid(5)}`;
    let checked = 'checked';
    const tabs = nodes.reduce((ns, node) => {
        if (node.type !== 'code')
            return ns;
        const id = nanoid(7);
        const lang = node.lang ?? '';
        ns.push({
            type: 'paragraph',
            children: [],
            data: {
                hName: 'input',
                hProperties: {
                    type: 'radio',
                    id: `tab-${id}`,
                    name: groupName,
                    checked,
                },
            },
        });
        ns.push({
            type: 'paragraph',
            children: [{ type: 'text', value: lang }],
            data: {
                hName: 'label',
                hProperties: {
                    for: `tab-${id}`,
                },
            },
        });
        checked = '';
        return ns;
    }, []);
    return {
        type: 'container',
        children: tabs,
        data: {
            hName: 'div',
            hProperties: {
                className: ['tabs'],
            },
        },
    };
}
function transformCodes(nodes) {
    let checked = 'checked';
    const blockChildren = nodes.map(node => {
        if (node.type !== 'code')
            return node;
        const lang = node.lang ?? '';
        const classNames = checked ? [`language-${lang}`, 'active'] : [`language-${lang}`];
        checked = '';
        return {
            type: 'container',
            children: [node],
            data: {
                hName: 'div',
                hProperties: {
                    className: classNames,
                },
            },
        };
    });
    return [
        {
            type: 'container',
            children: blockChildren,
            data: {
                hName: 'div',
                hProperties: {
                    className: ['blocks'],
                },
            },
        },
    ];
}
function checkIsContainer(node) {
    const firstChildren = node.children[0];
    if (firstChildren.type !== 'text')
        return false;
    const value = firstChildren.value;
    if (BAD_CONTAINER_REG.test(value))
        return false;
    return CONTAINER_START.test(value);
}
function checkIsCompleteContainerNode(node) {
    const firstChildren = node.children[0];
    if (node.children.length > 1) {
        const lastChildren = node.children[node.children.length - 1];
        return CONTAINER_START.test(firstChildren.value) && CONTAINER_END.test(lastChildren.value);
    }
    else {
        const firstChildren = node.children[0];
        const semicolonCount = firstChildren.value.match(/:/g)?.length ?? 0;
        return CONTAINER_START.test(firstChildren.value) && CONTAINER_END.test(firstChildren.value) && semicolonCount >= 6;
    }
}
function findClosingNode(parent, node) {
    return findAfter(parent, node, (n) => {
        const nodeChildren = n.children;
        return (n.type === 'paragraph' &&
            CONTAINER_END.test(nodeChildren[nodeChildren.length - 1]?.value));
    });
}
function analyzeParamsString(paramsStr) {
    let title = undefined;
    let type = settings.containerType;
    let alias = '';
    const props = {
        className: [],
    };
    if (!paramsStr) {
        return {
            title,
            alias,
            type,
            props,
        };
    }
    const params = paramsStr.split(' ');
    const typeAndProp = params.shift() ?? '';
    const match = typeAndProp.match(PARAM_REG);
    if (match && match[1]) {
        const lowerCaseType = match[1].toLowerCase();
        if (!TAGS_ALIAS.includes(lowerCaseType) || lowerCaseType === 'details') {
            type = lowerCaseType;
        }
        if (TAGS_ALIAS.includes(lowerCaseType)) {
            alias = lowerCaseType;
            props.className?.push(lowerCaseType);
        }
    }
    if (match && match[2] && (match[3] === '.' || match[3] === '#')) {
        if (match[3] === '.') {
            props.className?.push(match[4]);
        }
        else if (match[3] === '#') {
            props.id = match[4];
        }
    }
    if (params.length) {
        title = params.join(' ');
    }
    return {
        title,
        type,
        alias,
        props,
    };
}
function analyzeChild(node) {
    const textElement = node.children[0];
    const mainContent = textElement.value
        .replace(/^(:{3}) */, '');
    if (mainContent.includes('\n')) {
        const firstLinefeedIndex = mainContent.indexOf('\n');
        textElement.value = mainContent.slice(firstLinefeedIndex);
        const paramsStr = mainContent.slice(0, firstLinefeedIndex).trim();
        return analyzeParamsString(paramsStr);
    }
    else {
        const paramsStr = mainContent.trim();
        return analyzeParamsString(paramsStr);
    }
}
function replaceCloseSemicolon(node) {
    const { children } = node;
    const lastChild = children[children.length - 1];
    if (lastChild.type === 'text') {
        lastChild.value = lastChild.value.replace(CONTAINER_END, '');
        if (!lastChild.value) {
            node.children.pop();
        }
    }
}
function analyzeClosingNode(node) {
    replaceCloseSemicolon(node);
    return !!node.children.length;
}
const visitor = (node, index = 0, parent) => {
    if (!parent)
        return;
    if (!checkIsContainer(node))
        return;
    const completeFlag = checkIsCompleteContainerNode(node);
    const { type, title, props, alias } = analyzeChild(node);
    if (completeFlag) {
        replaceCloseSemicolon(node);
    }
    const containerChildren = [node];
    if (alias !== 'code-group' && title) {
        const titleNode = createTitle(title, type === 'details' ? 'summary' : settings.titleType);
        containerChildren.unshift(titleNode);
    }
    let deleteCount = 1;
    if (!completeFlag) {
        const closingNode = findClosingNode(parent, node);
        if (!closingNode)
            return;
        if (!node.children[0].value.includes('\n')) {
            containerChildren.pop();
        }
        const closeFlag = analyzeClosingNode(closingNode);
        let originContainerChildren = findAllBetween(parent, node, closingNode);
        if (alias === 'code-group') {
            const tabsNode = createTabs(originContainerChildren);
            containerChildren.unshift(tabsNode);
            originContainerChildren = transformCodes(originContainerChildren);
        }
        containerChildren.push(...originContainerChildren);
        if (closeFlag) {
            containerChildren.push(closingNode);
        }
        const closingIndex = parent.children.indexOf(closingNode);
        deleteCount = closingIndex - index + 1;
    }
    const container = createContainer(type ?? '', props, containerChildren);
    parent.children.splice(index, deleteCount, container);
};
const transformer = (tree) => {
    return visit(tree, 'paragraph', visitor);
};
const plugin = (options) => {
    Object.assign(settings, options);
    return transformer;
};
export default plugin;
