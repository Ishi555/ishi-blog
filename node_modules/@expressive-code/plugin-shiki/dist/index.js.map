{"version":3,"sources":["../src/index.ts","../src/highlighter.ts","../src/transformers.ts"],"sourcesContent":["import { ExpressiveCodeLine, ExpressiveCodePlugin, ExpressiveCodeTheme, InlineStyleAnnotation } from '@expressive-code/core'\nimport { type LanguageInput, ensureLanguageIsLoaded, ensureThemeIsLoaded, getCachedHighlighter } from './highlighter'\nimport { runPreprocessHook, runTokensHook, validateTransformers } from './transformers'\nimport type { ThemedToken, ShikiTransformer } from 'shiki'\nimport { bundledThemes } from 'shiki'\n\nexport interface PluginShikiOptions {\n\t/**\n\t * A list of additional languages that should be available for syntax highlighting.\n\t *\n\t * You can pass any of the language input types supported by Shiki, e.g.:\n\t * - `import('./some-exported-grammar.mjs')`\n\t * - `async () => JSON.parse(await fs.readFile('some-json-grammar.json', 'utf-8'))`\n\t *\n\t * See the [Shiki documentation](https://shiki.style/guide/load-lang) for more information.\n\t */\n\tlangs?: LanguageInput[] | undefined\n\t/**\n\t * An optional list of Shiki transformers.\n\t *\n\t * **Warning:** This option is experimental and only supports a very limited subset of\n\t * transformer features. Currently, only the `preprocess` and `tokens` hooks are supported,\n\t * and only if they do not modify the code block's text.\n\t *\n\t * Trying to use unsupported features will throw an error. For more information, see:\n\t *\n\t * https://expressive-code.com/key-features/syntax-highlighting/#transformers\n\t */\n\ttransformers?: ShikiTransformer[] | undefined\n}\n\n/**\n * A list of all themes bundled with Shiki.\n */\nexport type BundledShikiTheme = Exclude<keyof typeof bundledThemes, 'css-variables'>\n\n/**\n * Loads a theme bundled with Shiki for use with Expressive Code.\n */\nexport async function loadShikiTheme(bundledThemeName: BundledShikiTheme) {\n\tconst shikiTheme = (await bundledThemes[bundledThemeName]()).default\n\treturn new ExpressiveCodeTheme(shikiTheme)\n}\n\n// Workaround: Shiki exports this as an ambient enum, which throws an error when trying to\n// access its values at runtime, so we're defining it ourselves here as a regular enum.\nenum FontStyle {\n\tNotSet = -1,\n\tNone = 0,\n\tItalic = 1,\n\tBold = 2,\n\tUnderline = 4,\n}\n\nexport function pluginShiki(options: PluginShikiOptions = {}): ExpressiveCodePlugin {\n\tconst { langs } = options\n\n\t// Validate all configured transformers\n\tvalidateTransformers(options)\n\n\treturn {\n\t\tname: 'Shiki',\n\t\thooks: {\n\t\t\tperformSyntaxAnalysis: async ({ codeBlock, styleVariants, config: { logger } }) => {\n\t\t\t\tconst codeLines = codeBlock.getLines()\n\t\t\t\tlet code = codeBlock.code\n\n\t\t\t\t// If the code block uses a terminal language and includes placeholder strings\n\t\t\t\t// in angle brackets (e.g. `<username>`), Shiki will treat the closing `>` as\n\t\t\t\t// a redirect operator and highlight the character before it differently.\n\t\t\t\t// We work around this by replacing the brackets around such placeholder strings\n\t\t\t\t// with different characters that Shiki will not interpret as operators.\n\t\t\t\tif (isTerminalLanguage(codeBlock.language)) {\n\t\t\t\t\tcode = code.replace(/<([^>]*[^>\\s])>/g, 'X$1X')\n\t\t\t\t}\n\n\t\t\t\tlet highlighter\n\t\t\t\ttry {\n\t\t\t\t\thighlighter = await getCachedHighlighter({ langs })\n\t\t\t\t} catch (err) {\n\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\tconst error = err instanceof Error ? err : new Error(String(err))\n\t\t\t\t\tthrow new Error(`Failed to load syntax highlighter. Please ensure that the configured langs are supported by Shiki.\\nReceived error message: \"${error.message}\"`, {\n\t\t\t\t\t\tcause: error,\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\t// Load language if necessary\n\t\t\t\tconst loadedLanguageName = await ensureLanguageIsLoaded(highlighter, codeBlock.language)\n\t\t\t\t// If the requested language wasn't available, log a warning\n\t\t\t\tif (loadedLanguageName !== codeBlock.language) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Found unknown code block language \"${codeBlock.language}\" in ${\n\t\t\t\t\t\t\tcodeBlock.parentDocument?.sourceFilePath ? `document \"${codeBlock.parentDocument?.sourceFilePath}\"` : 'markdown/MDX document'\n\t\t\t\t\t\t}. Using \"${loadedLanguageName}\" instead. You can add custom languages using the \"langs\" config option.`\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tfor (let styleVariantIndex = 0; styleVariantIndex < styleVariants.length; styleVariantIndex++) {\n\t\t\t\t\tconst theme = styleVariants[styleVariantIndex].theme\n\n\t\t\t\t\t// Load theme if necessary\n\t\t\t\t\tconst loadedThemeName = await ensureThemeIsLoaded(highlighter, theme, styleVariants)\n\n\t\t\t\t\t// Run highlighter (by default, without explanations to improve performance)\n\t\t\t\t\tlet tokenLines: ThemedToken[][]\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst codeToTokensOptions = {\n\t\t\t\t\t\t\tlang: loadedLanguageName,\n\t\t\t\t\t\t\ttheme: loadedThemeName,\n\t\t\t\t\t\t\tincludeExplanation: false,\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Run preprocess hook of all configured transformers\n\t\t\t\t\t\trunPreprocessHook({ options, code, codeBlock, codeToTokensOptions })\n\n\t\t\t\t\t\ttokenLines = highlighter.codeToTokensBase(\n\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t// @ts-expect-error: We took care that the language and theme are loaded\n\t\t\t\t\t\t\tcodeToTokensOptions\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\t// Run tokens hook of all configured transformers\n\t\t\t\t\t\ttokenLines = runTokensHook({ options, code, codeBlock, codeToTokensOptions, tokenLines })\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\t\tconst error = err instanceof Error ? err : new Error(String(err))\n\t\t\t\t\t\tthrow new Error(`Failed to highlight code block with language \"${codeBlock.language}\" and theme \"${theme.name}\".\\nReceived error message: \"${error.message}\"`, {\n\t\t\t\t\t\t\tcause: error,\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\n\t\t\t\t\ttokenLines.forEach((line, lineIndex) => {\n\t\t\t\t\t\tif (codeBlock.language === 'ansi' && styleVariantIndex === 0) removeAnsiSequencesFromCodeLine(codeLines[lineIndex], line)\n\n\t\t\t\t\t\tlet charIndex = 0\n\t\t\t\t\t\tline.forEach((token) => {\n\t\t\t\t\t\t\tconst tokenLength = token.content.length\n\t\t\t\t\t\t\tconst tokenEndIndex = charIndex + tokenLength\n\t\t\t\t\t\t\tconst fontStyle = token.fontStyle || FontStyle.None\n\t\t\t\t\t\t\tcodeLines[lineIndex]?.addAnnotation(\n\t\t\t\t\t\t\t\tnew InlineStyleAnnotation({\n\t\t\t\t\t\t\t\t\tstyleVariantIndex,\n\t\t\t\t\t\t\t\t\tcolor: token.color || theme.fg,\n\t\t\t\t\t\t\t\t\titalic: ((fontStyle & FontStyle.Italic) as FontStyle) === FontStyle.Italic,\n\t\t\t\t\t\t\t\t\tbold: ((fontStyle & FontStyle.Bold) as FontStyle) === FontStyle.Bold,\n\t\t\t\t\t\t\t\t\tunderline: ((fontStyle & FontStyle.Underline) as FontStyle) === FontStyle.Underline,\n\t\t\t\t\t\t\t\t\tinlineRange: {\n\t\t\t\t\t\t\t\t\t\tcolumnStart: charIndex,\n\t\t\t\t\t\t\t\t\t\tcolumnEnd: tokenEndIndex,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trenderPhase: 'earliest',\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tcharIndex = tokenEndIndex\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunction isTerminalLanguage(language: string) {\n\treturn ['shellscript', 'shell', 'bash', 'sh', 'zsh', 'nu', 'nushell'].includes(language)\n}\n\n/**\n * Removes ANSI sequences processed by Shiki from the provided codeline\n */\nfunction removeAnsiSequencesFromCodeLine(codeLine: ExpressiveCodeLine, lineTokens: ThemedToken[]): void {\n\t// The provided tokens from Shiki will already be stripped for control characters\n\tconst newLine = lineTokens.map((token) => token.content).join('')\n\t// Removing sequences by ranges instead of whole line to avoid breaking any existing annotations\n\tconst rangesToRemove = getRemovedRanges(codeLine.text, newLine)\n\tfor (let index = rangesToRemove.length - 1; index >= 0; index--) {\n\t\tconst [start, end] = rangesToRemove[index]\n\t\tcodeLine.editText(start, end, '')\n\t}\n}\n\n/**\n * Compares a given `original` string to its `edited` version, assuming that the only kind of edits\n * allowed between them is the removal of column ranges from the original string.\n *\n * Returns an array of column ranges that were removed from the original string.\n */\nfunction getRemovedRanges(original: string, edited: string): [start: number, end: number][] {\n\tconst ranges: [start: number, ends: number][] = []\n\tlet from = -1\n\tlet orgIdx = 0\n\tlet edtIdx = 0\n\n\twhile (orgIdx < original.length && edtIdx < edited.length) {\n\t\tif (original[orgIdx] !== edited[edtIdx]) {\n\t\t\tif (from === -1) from = orgIdx\n\t\t\torgIdx++\n\t\t} else {\n\t\t\tif (from > -1) {\n\t\t\t\tranges.push([from, orgIdx])\n\t\t\t\tfrom = -1\n\t\t\t}\n\t\t\torgIdx++\n\t\t\tedtIdx++\n\t\t}\n\t}\n\n\tif (edtIdx < edited.length) throw new Error(`Edited string contains characters not present in original (${JSON.stringify({ original, edited })})`)\n\n\tif (orgIdx < original.length) ranges.push([orgIdx, original.length])\n\n\treturn ranges\n}\n","import { Highlighter, ThemeRegistration, bundledLanguages, createHighlighter, isSpecialLang } from 'shiki'\nimport type { LanguageInput as ShikiLanguageInput, LanguageRegistration as ShikiLanguageRegistration, MaybeGetter, MaybeArray, BundledLanguage } from 'shiki'\nimport { ExpressiveCodeTheme, getStableObjectHash } from '@expressive-code/core'\nimport type { StyleVariant } from '@expressive-code/core'\n\n// Unfortunately, the types exported by `vscode-textmate` that are used by Shiki\n// don't match the actual grammar requirements & parsing logic in some aspects.\n// The types defined here attempt to reduce the amount of incorrect type errors\n// that would otherwise when importing and adding external grammars.\ntype Optional<T, K extends keyof T> = Omit<T, K> & Pick<Partial<T>, K>\ntype IRawRepository = Optional<ShikiLanguageRegistration['repository'], '$self' | '$base'>\nexport interface LanguageRegistration extends Omit<ShikiLanguageRegistration, 'repository'> {\n\trepository?: IRawRepository | undefined\n}\nexport type LanguageInput = MaybeGetter<MaybeArray<LanguageRegistration>>\n\nconst highlighterPromiseByConfig = new Map<string, Promise<Highlighter>>()\nconst promisesByHighlighter = new WeakMap<Highlighter, Map<string, Promise<unknown>>>()\n// We store theme cache keys by style variant arrays because style variant arrays are unique per engine,\n// and we can be confident that the same theme object used by the same engine has the same contents\nconst themeCacheKeysByStyleVariants = new WeakMap<StyleVariant[], WeakMap<ExpressiveCodeTheme, string>>()\n\n/**\n * Gets a cached Shiki highlighter instance for the given configuration.\n */\nexport async function getCachedHighlighter(config: { langs?: LanguageInput[] | undefined } = {}): Promise<Highlighter> {\n\tconst configCacheKey = getStableObjectHash(config)\n\tlet highlighterPromise = highlighterPromiseByConfig.get(configCacheKey)\n\tif (highlighterPromise === undefined) {\n\t\tconst langs: (ShikiLanguageInput | BundledLanguage)[] = []\n\t\tif (config.langs?.length) {\n\t\t\tlangs.push(...(config.langs as ShikiLanguageInput[]))\n\t\t}\n\t\t// For now, always preload all the languages because we had some strange race conditions\n\t\t// with lazy-loading that we couldn't solve yet. This is what the old version did as well.\n\t\tlangs.push(...(Object.keys(bundledLanguages) as BundledLanguage[]))\n\t\thighlighterPromise = createHighlighter({\n\t\t\tthemes: [],\n\t\t\tlangs,\n\t\t})\n\t\thighlighterPromiseByConfig.set(configCacheKey, highlighterPromise)\n\t}\n\treturn highlighterPromise\n}\n\nexport async function ensureThemeIsLoaded(highlighter: Highlighter, theme: ExpressiveCodeTheme, styleVariants: StyleVariant[]) {\n\t// Unfortunately, Shiki caches themes by name, so we need to ensure that the theme name changes\n\t// whenever the theme contents change by appending a content hash\n\tlet themeCacheKeys = themeCacheKeysByStyleVariants.get(styleVariants)\n\tif (!themeCacheKeys) {\n\t\tthemeCacheKeys = new WeakMap<ExpressiveCodeTheme, string>()\n\t\tthemeCacheKeysByStyleVariants.set(styleVariants, themeCacheKeys)\n\t}\n\tconst existingCacheKey = themeCacheKeys.get(theme)\n\tconst cacheKey = existingCacheKey ?? `${theme.name}-${getStableObjectHash({ bg: theme.bg, fg: theme.fg, settings: theme.settings })}`\n\tif (!existingCacheKey) themeCacheKeys.set(theme, cacheKey)\n\n\t// Only load the theme if it hasn't been loaded yet\n\tif (!highlighter.getLoadedThemes().includes(cacheKey)) {\n\t\t// Load the theme or wait for an existing load task to finish\n\t\tawait memoizeHighlighterTask(highlighter, `loadTheme:${cacheKey}`, () => {\n\t\t\tconst themeUsingCacheKey = { ...theme, name: cacheKey, settings: (theme.settings as ThemeRegistration['settings']) ?? [] }\n\t\t\treturn highlighter.loadTheme(themeUsingCacheKey)\n\t\t})\n\t}\n\treturn cacheKey\n}\n\nexport async function ensureLanguageIsLoaded(highlighter: Highlighter, language: string) {\n\tconst loadedLanguages = new Set(highlighter.getLoadedLanguages())\n\tconst isLoaded = loadedLanguages.has(language)\n\tconst isSpecial = isSpecialLang(language)\n\tconst isBundled = Object.keys(bundledLanguages).includes(language)\n\t// If the language is not available, fall back to \"txt\"\n\tconst isAvailable = isLoaded || isSpecial || isBundled\n\tif (!isAvailable) return 'txt'\n\tif (isLoaded || isSpecial) return language\n\t// Load the language or wait for an existing load task to finish\n\tconst loadedLanguage = await memoizeHighlighterTask(highlighter, `loadLanguage:${language}`, async () => {\n\t\tawait highlighter.loadLanguage(language as BundledLanguage)\n\t\treturn language\n\t})\n\treturn loadedLanguage\n}\n\n/**\n * Memoizes a task by ID for a given highlighter instance.\n *\n * This is necessary because SSGs can process multiple pages in parallel and we don't want to\n * start the same async task multiple times, but instead return the same promise for all calls\n * to improve performance and reduce memory usage.\n */\nfunction memoizeHighlighterTask<T>(highlighter: Highlighter, taskId: string, taskFn: () => Promise<T>) {\n\tlet promises = promisesByHighlighter.get(highlighter)\n\tif (!promises) {\n\t\tpromises = new Map()\n\t\tpromisesByHighlighter.set(highlighter, promises)\n\t}\n\tlet promise = promises.get(taskId)\n\tif (promise === undefined) {\n\t\tpromise = taskFn()\n\t\tpromises.set(taskId, promise)\n\t}\n\treturn promise as Promise<T>\n}\n","import { ExpressiveCodeBlock } from '@expressive-code/core'\nimport type { PluginShikiOptions } from '.'\nimport type { CodeToHastOptions, ShikiTransformer, ShikiTransformerContextSource, ThemedToken } from 'shiki'\n\nexport type BaseHookArgs = {\n\toptions: PluginShikiOptions\n\tcode: string\n\tcodeBlock: ExpressiveCodeBlock\n\tcodeToTokensOptions: CodeToHastOptions\n}\n\n/**\n * Throws an error if any of the configured transformers use unsupported hooks.\n */\nexport function validateTransformers(options: PluginShikiOptions) {\n\tif (!options.transformers) return\n\tconst unsupportedTransformerHooks: (keyof ShikiTransformer)[] = ['code', 'line', 'postprocess', 'pre', 'root', 'span']\n\tfor (const transformer of options.transformers) {\n\t\tconst unsupportedHook = unsupportedTransformerHooks.find((hook) => transformer[hook] != null)\n\t\tif (unsupportedHook) {\n\t\t\tthrow new ExpressiveCodeShikiTransformerError(transformer, `The transformer hook \"${unsupportedHook}\" is not supported by Expressive Code yet.`)\n\t\t}\n\t}\n}\n\nexport function runPreprocessHook(args: BaseHookArgs) {\n\tconst { options, code, codeBlock, codeToTokensOptions } = args\n\toptions.transformers?.forEach((transformer) => {\n\t\tif (!transformer.preprocess) return\n\t\tconst transformerContext = getTransformerContext({ transformer, code, codeBlock, codeToTokensOptions })\n\t\tconst transformedCode = transformer.preprocess.call(transformerContext, code, codeToTokensOptions)\n\t\tif (typeof transformedCode === 'string' && transformedCode !== code) {\n\t\t\tthrow new ExpressiveCodeShikiTransformerError(transformer, `Transformers that modify code in the \"preprocess\" hook are not supported yet.`)\n\t\t}\n\t})\n}\n\nexport function runTokensHook(args: BaseHookArgs & { tokenLines: ThemedToken[][] }) {\n\tconst { options, code, codeBlock, codeToTokensOptions } = args\n\tconst originalTokenLinesText = getTokenLinesText(args.tokenLines)\n\toptions.transformers?.forEach((transformer) => {\n\t\tif (!transformer.tokens) return\n\t\tconst transformerContext = getTransformerContext({ transformer, code, codeBlock, codeToTokensOptions })\n\t\tconst transformedTokenLines = transformer.tokens.call(transformerContext, args.tokenLines)\n\t\t// Transformers can either mutate the tokens in place,\n\t\t// or return a new array of tokens\n\t\tif (transformedTokenLines) {\n\t\t\targs.tokenLines = transformedTokenLines\n\t\t}\n\t\t// Ensure that the transformer didn't change the text contents of the tokens\n\t\tconst newTokenLinesText = getTokenLinesText(args.tokenLines)\n\t\tif (originalTokenLinesText.length !== args.tokenLines.length) {\n\t\t\tthrow new ExpressiveCodeShikiTransformerError(\n\t\t\t\ttransformer,\n\t\t\t\t`Transformers that modify code in the \"tokens\" hook are not supported yet. The number of lines changed from ${originalTokenLinesText.length} to ${args.tokenLines.length}.`\n\t\t\t)\n\t\t}\n\t\tfor (let i = 0; i < newTokenLinesText.length; i++) {\n\t\t\tif (originalTokenLinesText[i] !== newTokenLinesText[i]) {\n\t\t\t\tthrow new ExpressiveCodeShikiTransformerError(\n\t\t\t\t\ttransformer,\n\t\t\t\t\t`Transformers that modify code in the \"tokens\" hook are not supported yet. Line ${i + 1} changed from \"${originalTokenLinesText[i]}\" to \"${newTokenLinesText[i]}\".`\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t})\n\treturn args.tokenLines\n}\n\nfunction getTokenLinesText(tokenLines: ThemedToken[][]) {\n\treturn tokenLines.map((line) => line.map((token) => token.content).join(''))\n}\n\nexport function getTransformerContext(contextBase: {\n\ttransformer: ShikiTransformer\n\tcode: string\n\tcodeBlock: ExpressiveCodeBlock\n\tcodeToTokensOptions: CodeToHastOptions\n}): ShikiTransformerContextSource {\n\tconst { transformer, code, codeBlock, codeToTokensOptions } = contextBase\n\tconst getUnsupportedFnHandler = (name: string) => {\n\t\treturn () => {\n\t\t\tthrow new ExpressiveCodeShikiTransformerError(transformer, `The context function \"${name}\" is not available in Expressive Code transformers yet.`)\n\t\t}\n\t}\n\treturn {\n\t\tsource: code,\n\t\toptions: codeToTokensOptions,\n\t\tmeta: {\n\t\t\t...(Object.fromEntries(codeBlock.metaOptions.list().map((option) => [option.key, option.value])) as Record<string, string | boolean | RegExp>),\n\t\t\t__raw: codeBlock.meta,\n\t\t},\n\t\tcodeToHast: getUnsupportedFnHandler('codeToHast'),\n\t\tcodeToTokens: getUnsupportedFnHandler('codeToTokens'),\n\t}\n}\n\nexport class ExpressiveCodeShikiTransformerError extends Error {\n\tconstructor(transformer: ShikiTransformer, message: string) {\n\t\tsuper(\n\t\t\t`Failed to run Shiki transformer${transformer.name ? ` \"${transformer.name}\"` : ''}: ${message}\n\t\t\t\n\t\t\tIMPORTANT: This is not a bug - neither in Shiki, nor in the transformer or Expressive Code.\n\t\t\tTransformer support in Expressive Code is still experimental and limited to a few cases\n\t\t\t(e.g. transformers that modify syntax highlighting tokens).\n\n\t\t\tTo continue, remove this transformer from the Expressive Code configuration,\n\t\t\tor visit the following link for more information and other options:\n\t\t\thttps://expressive-code.com/key-features/syntax-highlighting/#transformers`\n\t\t\t\t.replace(/^\\t+/gm, '')\n\t\t\t\t.replace(/(?<!\\n)\\n(?!\\n)/g, ' ')\n\t\t)\n\t\tthis.name = 'ExpressiveCodeShikiTransformerError'\n\t}\n}\n"],"mappings":"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","names":["ExpressiveCodeTheme","ExpressiveCodeTheme"]}