// src/index.ts
import { ExpressiveCodeTheme as ExpressiveCodeTheme2, InlineStyleAnnotation } from "@expressive-code/core";

// src/highlighter.ts
import { bundledLanguages, createHighlighter, isSpecialLang } from "shiki";
import { getStableObjectHash } from "@expressive-code/core";
var highlighterPromiseByConfig = /* @__PURE__ */ new Map();
var promisesByHighlighter = /* @__PURE__ */ new WeakMap();
var themeCacheKeysByStyleVariants = /* @__PURE__ */ new WeakMap();
async function getCachedHighlighter(config = {}) {
  const configCacheKey = getStableObjectHash(config);
  let highlighterPromise = highlighterPromiseByConfig.get(configCacheKey);
  if (highlighterPromise === void 0) {
    const langs = [];
    if (config.langs?.length) {
      langs.push(...config.langs);
    }
    langs.push(...Object.keys(bundledLanguages));
    highlighterPromise = createHighlighter({
      themes: [],
      langs
    });
    highlighterPromiseByConfig.set(configCacheKey, highlighterPromise);
  }
  return highlighterPromise;
}
async function ensureThemeIsLoaded(highlighter, theme, styleVariants) {
  let themeCacheKeys = themeCacheKeysByStyleVariants.get(styleVariants);
  if (!themeCacheKeys) {
    themeCacheKeys = /* @__PURE__ */ new WeakMap();
    themeCacheKeysByStyleVariants.set(styleVariants, themeCacheKeys);
  }
  const existingCacheKey = themeCacheKeys.get(theme);
  const cacheKey = existingCacheKey ?? `${theme.name}-${getStableObjectHash({ bg: theme.bg, fg: theme.fg, settings: theme.settings })}`;
  if (!existingCacheKey)
    themeCacheKeys.set(theme, cacheKey);
  if (!highlighter.getLoadedThemes().includes(cacheKey)) {
    await memoizeHighlighterTask(highlighter, `loadTheme:${cacheKey}`, () => {
      const themeUsingCacheKey = { ...theme, name: cacheKey, settings: theme.settings ?? [] };
      return highlighter.loadTheme(themeUsingCacheKey);
    });
  }
  return cacheKey;
}
async function ensureLanguageIsLoaded(highlighter, language) {
  const loadedLanguages = new Set(highlighter.getLoadedLanguages());
  const isLoaded = loadedLanguages.has(language);
  const isSpecial = isSpecialLang(language);
  const isBundled = Object.keys(bundledLanguages).includes(language);
  const isAvailable = isLoaded || isSpecial || isBundled;
  if (!isAvailable)
    return "txt";
  if (isLoaded || isSpecial)
    return language;
  const loadedLanguage = await memoizeHighlighterTask(highlighter, `loadLanguage:${language}`, async () => {
    await highlighter.loadLanguage(language);
    return language;
  });
  return loadedLanguage;
}
function memoizeHighlighterTask(highlighter, taskId, taskFn) {
  let promises = promisesByHighlighter.get(highlighter);
  if (!promises) {
    promises = /* @__PURE__ */ new Map();
    promisesByHighlighter.set(highlighter, promises);
  }
  let promise = promises.get(taskId);
  if (promise === void 0) {
    promise = taskFn();
    promises.set(taskId, promise);
  }
  return promise;
}

// src/transformers.ts
function validateTransformers(options) {
  if (!options.transformers)
    return;
  const unsupportedTransformerHooks = ["code", "line", "postprocess", "pre", "root", "span"];
  for (const transformer of options.transformers) {
    const unsupportedHook = unsupportedTransformerHooks.find((hook) => transformer[hook] != null);
    if (unsupportedHook) {
      throw new ExpressiveCodeShikiTransformerError(transformer, `The transformer hook "${unsupportedHook}" is not supported by Expressive Code yet.`);
    }
  }
}
function runPreprocessHook(args) {
  const { options, code, codeBlock, codeToTokensOptions } = args;
  options.transformers?.forEach((transformer) => {
    if (!transformer.preprocess)
      return;
    const transformerContext = getTransformerContext({ transformer, code, codeBlock, codeToTokensOptions });
    const transformedCode = transformer.preprocess.call(transformerContext, code, codeToTokensOptions);
    if (typeof transformedCode === "string" && transformedCode !== code) {
      throw new ExpressiveCodeShikiTransformerError(transformer, `Transformers that modify code in the "preprocess" hook are not supported yet.`);
    }
  });
}
function runTokensHook(args) {
  const { options, code, codeBlock, codeToTokensOptions } = args;
  const originalTokenLinesText = getTokenLinesText(args.tokenLines);
  options.transformers?.forEach((transformer) => {
    if (!transformer.tokens)
      return;
    const transformerContext = getTransformerContext({ transformer, code, codeBlock, codeToTokensOptions });
    const transformedTokenLines = transformer.tokens.call(transformerContext, args.tokenLines);
    if (transformedTokenLines) {
      args.tokenLines = transformedTokenLines;
    }
    const newTokenLinesText = getTokenLinesText(args.tokenLines);
    if (originalTokenLinesText.length !== args.tokenLines.length) {
      throw new ExpressiveCodeShikiTransformerError(
        transformer,
        `Transformers that modify code in the "tokens" hook are not supported yet. The number of lines changed from ${originalTokenLinesText.length} to ${args.tokenLines.length}.`
      );
    }
    for (let i = 0; i < newTokenLinesText.length; i++) {
      if (originalTokenLinesText[i] !== newTokenLinesText[i]) {
        throw new ExpressiveCodeShikiTransformerError(
          transformer,
          `Transformers that modify code in the "tokens" hook are not supported yet. Line ${i + 1} changed from "${originalTokenLinesText[i]}" to "${newTokenLinesText[i]}".`
        );
      }
    }
  });
  return args.tokenLines;
}
function getTokenLinesText(tokenLines) {
  return tokenLines.map((line) => line.map((token) => token.content).join(""));
}
function getTransformerContext(contextBase) {
  const { transformer, code, codeBlock, codeToTokensOptions } = contextBase;
  const getUnsupportedFnHandler = (name) => {
    return () => {
      throw new ExpressiveCodeShikiTransformerError(transformer, `The context function "${name}" is not available in Expressive Code transformers yet.`);
    };
  };
  return {
    source: code,
    options: codeToTokensOptions,
    meta: {
      ...Object.fromEntries(codeBlock.metaOptions.list().map((option) => [option.key, option.value])),
      __raw: codeBlock.meta
    },
    codeToHast: getUnsupportedFnHandler("codeToHast"),
    codeToTokens: getUnsupportedFnHandler("codeToTokens")
  };
}
var ExpressiveCodeShikiTransformerError = class extends Error {
  constructor(transformer, message) {
    super(
      `Failed to run Shiki transformer${transformer.name ? ` "${transformer.name}"` : ""}: ${message}
			
			IMPORTANT: This is not a bug - neither in Shiki, nor in the transformer or Expressive Code.
			Transformer support in Expressive Code is still experimental and limited to a few cases
			(e.g. transformers that modify syntax highlighting tokens).

			To continue, remove this transformer from the Expressive Code configuration,
			or visit the following link for more information and other options:
			https://expressive-code.com/key-features/syntax-highlighting/#transformers`.replace(/^\t+/gm, "").replace(/(?<!\n)\n(?!\n)/g, " ")
    );
    this.name = "ExpressiveCodeShikiTransformerError";
  }
};

// src/index.ts
import { bundledThemes } from "shiki";
async function loadShikiTheme(bundledThemeName) {
  const shikiTheme = (await bundledThemes[bundledThemeName]()).default;
  return new ExpressiveCodeTheme2(shikiTheme);
}
function pluginShiki(options = {}) {
  const { langs } = options;
  validateTransformers(options);
  return {
    name: "Shiki",
    hooks: {
      performSyntaxAnalysis: async ({ codeBlock, styleVariants, config: { logger } }) => {
        const codeLines = codeBlock.getLines();
        let code = codeBlock.code;
        if (isTerminalLanguage(codeBlock.language)) {
          code = code.replace(/<([^>]*[^>\s])>/g, "X$1X");
        }
        let highlighter;
        try {
          highlighter = await getCachedHighlighter({ langs });
        } catch (err) {
          const error = err instanceof Error ? err : new Error(String(err));
          throw new Error(`Failed to load syntax highlighter. Please ensure that the configured langs are supported by Shiki.
Received error message: "${error.message}"`, {
            cause: error
          });
        }
        const loadedLanguageName = await ensureLanguageIsLoaded(highlighter, codeBlock.language);
        if (loadedLanguageName !== codeBlock.language) {
          logger.warn(
            `Found unknown code block language "${codeBlock.language}" in ${codeBlock.parentDocument?.sourceFilePath ? `document "${codeBlock.parentDocument?.sourceFilePath}"` : "markdown/MDX document"}. Using "${loadedLanguageName}" instead. You can add custom languages using the "langs" config option.`
          );
        }
        for (let styleVariantIndex = 0; styleVariantIndex < styleVariants.length; styleVariantIndex++) {
          const theme = styleVariants[styleVariantIndex].theme;
          const loadedThemeName = await ensureThemeIsLoaded(highlighter, theme, styleVariants);
          let tokenLines;
          try {
            const codeToTokensOptions = {
              lang: loadedLanguageName,
              theme: loadedThemeName,
              includeExplanation: false
            };
            runPreprocessHook({ options, code, codeBlock, codeToTokensOptions });
            tokenLines = highlighter.codeToTokensBase(
              code,
              // @ts-expect-error: We took care that the language and theme are loaded
              codeToTokensOptions
            );
            tokenLines = runTokensHook({ options, code, codeBlock, codeToTokensOptions, tokenLines });
          } catch (err) {
            const error = err instanceof Error ? err : new Error(String(err));
            throw new Error(`Failed to highlight code block with language "${codeBlock.language}" and theme "${theme.name}".
Received error message: "${error.message}"`, {
              cause: error
            });
          }
          tokenLines.forEach((line, lineIndex) => {
            if (codeBlock.language === "ansi" && styleVariantIndex === 0)
              removeAnsiSequencesFromCodeLine(codeLines[lineIndex], line);
            let charIndex = 0;
            line.forEach((token) => {
              const tokenLength = token.content.length;
              const tokenEndIndex = charIndex + tokenLength;
              const fontStyle = token.fontStyle || 0 /* None */;
              codeLines[lineIndex]?.addAnnotation(
                new InlineStyleAnnotation({
                  styleVariantIndex,
                  color: token.color || theme.fg,
                  italic: (fontStyle & 1 /* Italic */) === 1 /* Italic */,
                  bold: (fontStyle & 2 /* Bold */) === 2 /* Bold */,
                  underline: (fontStyle & 4 /* Underline */) === 4 /* Underline */,
                  inlineRange: {
                    columnStart: charIndex,
                    columnEnd: tokenEndIndex
                  },
                  renderPhase: "earliest"
                })
              );
              charIndex = tokenEndIndex;
            });
          });
        }
      }
    }
  };
}
function isTerminalLanguage(language) {
  return ["shellscript", "shell", "bash", "sh", "zsh", "nu", "nushell"].includes(language);
}
function removeAnsiSequencesFromCodeLine(codeLine, lineTokens) {
  const newLine = lineTokens.map((token) => token.content).join("");
  const rangesToRemove = getRemovedRanges(codeLine.text, newLine);
  for (let index = rangesToRemove.length - 1; index >= 0; index--) {
    const [start, end] = rangesToRemove[index];
    codeLine.editText(start, end, "");
  }
}
function getRemovedRanges(original, edited) {
  const ranges = [];
  let from = -1;
  let orgIdx = 0;
  let edtIdx = 0;
  while (orgIdx < original.length && edtIdx < edited.length) {
    if (original[orgIdx] !== edited[edtIdx]) {
      if (from === -1)
        from = orgIdx;
      orgIdx++;
    } else {
      if (from > -1) {
        ranges.push([from, orgIdx]);
        from = -1;
      }
      orgIdx++;
      edtIdx++;
    }
  }
  if (edtIdx < edited.length)
    throw new Error(`Edited string contains characters not present in original (${JSON.stringify({ original, edited })})`);
  if (orgIdx < original.length)
    ranges.push([orgIdx, original.length]);
  return ranges;
}
export {
  loadShikiTheme,
  pluginShiki
};
//# sourceMappingURL=index.js.map